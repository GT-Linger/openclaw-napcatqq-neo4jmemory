---
read_when:
  - 配置子智能体功能
summary: 子智能体使用规范模板
---

# 子智能体使用规范

子智能体是主智能体的"助手"，可以帮你并行处理多个任务。当你需要同时执行多个独立任务时，可以使用子智能体。

## 子智能体的工作原理

1. **启动时**：系统根据子智能体绑定的模型服务商自动处理（加载模型等）
2. **执行任务**：子智能体处理分配的任务
3. **完成后**：系统自动处理资源释放（卸载模型等）

## 基本使用

### 启动子智能体

```json
{
  "tool": "sessions_spawn",
  "parameters": {
    "task": "分析今天的销售数据",
    "label": "销售数据分析",
    "subagentId": "code-assistant"
  }
}
```

### 关键参数

| 参数 | 必填 | 说明 |
|------|------|------|
| `task` | 是 | 给子智能体的任务描述 |
| `label` | 是 | 任务标签，用于区分不同任务 |
| `subagentId` | 否 | 指定子智能体 ID（从子智能体列表选择） |
| `model` | 否 | 覆盖默认模型配置 |

### 接收结果

当子智能体完成时，会收到通告消息：

```
✅ Subagent main completed this task

Result:
[分析结果...]

A subagent task "销售数据分析" just completed successfully.
```

## 任务标签（label）的重要性

- 子智能体任务是**非阻塞**的，可以并行运行多个任务
- 当多个子智能体任务同时运行时，需要通过 `label` 区分每个任务的结果
- 结果返回时会带上 `label` 标识，帮助你准确将结果传达给用户

### 多任务示例

```json
// 同时启动两个任务
{
  "tool": "sessions_spawn",
  "parameters": {
    "task": "分析销售数据",
    "label": "销售数据分析"
  }
}
{
  "tool": "sessions_spawn",
  "parameters": {
    "task": "生成月度报告",
    "label": "月度报告生成"
  }
}
```

## 子智能体工作目录

每个子智能体都有独立的工作目录：

```
{workspaceDir}/subagents/{subagentId}/
├── personality.md      # 子智能体人格设定
├── system-prompt.md    # 自定义系统提示
├── tools.md           # 工具使用规范
├── behavior.md        # 行为规范
└── config.json         # 配置信息（由 subagents.json 统一管理）
```

子智能体会自动加载这些文件来获得特定的人格、工具使用规范和行为配置。

### 文件说明

| 文件 | 说明 | 必填 |
|------|------|------|
| `personality.md` | 身份与价值观设定 | 是 |
| `tools.md` | 工具使用规范 | 是 |
| `behavior.md` | 行为边界与禁止事项 | 是 |
| `system-prompt.md` | 自定义系统提示（可选） | 否 |

## 管理子智能体

### 列出子智能体

```json
{
  "tool": "subagents",
  "parameters": {
    "action": "list"
  }
}
```

### 查看子智能体状态

```json
{
  "tool": "subagents",
  "parameters": {
    "action": "status"
  }
}
```

### 终止子智能体

```json
{
  "tool": "subagents",
  "parameters": {
    "action": "kill",
    "runId": "xxx"
  }
}
```

## 最佳实践

1. **明确任务描述**：给子智能体清晰的任务说明
2. **使用标签**：始终使用 `label` 区分任务
3. **合理分工**：根据子智能体的专长分配任务
4. **并行处理**：独立任务可以并行执行
5. **结果汇总**：将子智能体结果整合后回复用户

## 使用场景示例

### 场景 1：代码审查

```
主智能体收到请求："帮我审查代码并搜索相关信息"

1. 启动子智能体A（代码助手）："审查这段代码"
2. 启动子智能体B（搜索助手）："搜索相关信息"
3. 等待两个子智能体完成
4. 整合结果返回给用户
```

### 场景 2：多文档处理

```
主智能体收到请求："总结这三个文档"

1. 启动三个子智能体分别处理每个文档
2. 等待全部完成
3. 汇总生成最终总结
```
